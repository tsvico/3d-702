<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>å…¨æ™¯åˆ‡ç‰‡å·¥å…·</title>
    <style>
      :root {
        --panel-bg: rgba(20, 20, 20, 0.95);
        --accent: #00d2ff;
        --danger: #ff4757;
        --border: rgba(255, 255, 255, 0.15);
        --text-main: #ffffff;
        --text-sub: #aaaaaa;
        --header-height: 60px;
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        color: var(--text-main);
        -webkit-tap-highlight-color: transparent;
      }

      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #ui-container {
        position: absolute;
        z-index: 10;
        background: var(--panel-bg);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        display: flex;
        flex-direction: column;
        transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.6);
      }

      @media (min-width: 769px) {
        #ui-container {
          top: 0;
          right: 0;
          bottom: 0;
          width: 380px;
          border-left: 1px solid var(--border);
        }

        .panel-handle {
          display: none;
        }

        .toggle-icon {
          display: none;
        }
      }

      @media (max-width: 768px) {
        #ui-container {
          left: 0;
          right: 0;
          bottom: 0;
          height: 65%;
          border-top: 1px solid var(--border);
          border-radius: 20px 20px 0 0;
          transform: translateY(0);
        }

        #ui-container.collapsed {
          transform: translateY(calc(100% - var(--header-height)));
        }

        .panel-handle {
          width: 40px;
          height: 5px;
          background: rgba(255, 255, 255, 0.3);
          border-radius: 10px;
          margin: 8px auto 0 auto;
        }
      }

      .panel-header {
        height: var(--header-height);
        padding: 0 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        cursor: pointer;
        user-select: none;
      }

      .header-content {
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex: 1;
      }

      h2 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        color: var(--accent);
      }

      .version {
        font-size: 11px;
        color: var(--text-sub);
        margin-top: 2px;
      }

      .toggle-icon {
        font-size: 12px;
        color: var(--text-sub);
        transition: transform 0.4s;
        background: rgba(255, 255, 255, 0.1);
        padding: 6px;
        border-radius: 50%;
      }

      #ui-container.collapsed .toggle-icon {
        transform: rotate(180deg);
      }

      .panel-content {
        flex: 1;
        padding: 10px 20px 30px 20px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        display: flex;
        flex-direction: column;
        gap: 16px;
        opacity: 1;
        transition: opacity 0.3s;
      }

      #ui-container.collapsed .panel-content {
        opacity: 0;
        pointer-events: none;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      label {
        font-size: 12px;
        color: var(--text-sub);
        font-weight: 500;
      }

      /* --- Select æ ·å¼ --- */
      select {
        padding: 12px;
        background-color: rgba(255, 255, 255, 0.1);
        /* èƒŒæ™¯è‰² */
        border: 1px solid var(--border);
        color: #fff;
        /* æ˜¾ç¤ºçš„æ–‡å­—é¢œè‰² */
        border-radius: 8px;
        font-size: 14px;
        outline: none;
        width: 100%;
        /* ç§»é™¤é»˜è®¤ç®­å¤´ï¼Œä½¿ç”¨è‡ªå®šä¹‰SVGç®­å¤´ */
        -webkit-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
      }

      /* å…³é”®ä¿®å¤ï¼šæŒ‡å®šä¸‹æ‹‰é€‰é¡¹çš„èƒŒæ™¯è‰²å’Œæ–‡å­—é¢œè‰² */
      select option {
        background-color: #222;
        color: #fff;
      }

      .btn-group {
        display: flex;
        gap: 10px;
      }

      button {
        flex: 1;
        padding: 14px 0;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: 0.2s;
      }

      button:disabled {
        opacity: 0.5;
        background: #333;
        color: #888;
      }

      .btn-primary {
        background: linear-gradient(135deg, #007bff, var(--accent));
        color: #fff;
      }

      .btn-danger {
        background: var(--danger);
        color: #fff;
        display: none;
      }

      .file-upload-box {
        border: 1px dashed rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.03);
        padding: 15px;
        text-align: center;
        border-radius: 10px;
      }

      .file-info {
        font-size: 13px;
        color: #fff;
      }

      .file-hint {
        font-size: 11px;
        color: var(--text-sub);
        margin-top: 4px;
      }

      #slices-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        padding-bottom: 20px;
      }

      .slice-item {
        aspect-ratio: 1;
        background: #000;
        border: 1px solid var(--border);
        border-radius: 8px;
        overflow: hidden;
        position: relative;
      }

      .slice-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .slice-tag {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        font-size: 10px;
        text-align: center;
        padding: 4px 0;
      }

      #progress-area {
        margin-top: 5px;
        display: none;
      }

      .progress-track {
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.3s;
      }

      .status-text {
        font-size: 12px;
        color: var(--accent);
        text-align: center;
        margin-top: 8px;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
          "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="canvas-container"></div>

    <div id="ui-container">
      <div class="panel-handle"></div>
      <div class="panel-header" id="panel-toggle">
        <div class="header-content">
          <h2>å…¨æ™¯åˆ‡ç‰‡å·¥å…·</h2>
          <span class="version">æ”¯æŒæ”¶èµ·é¢„è§ˆ Â· ç‚¹å‡»æ ‡é¢˜æŠ˜å </span>
        </div>
        <div class="toggle-icon">â–¼</div>
      </div>

      <div class="panel-content">
        <div class="control-group">
          <div
            class="file-upload-box"
            onclick="document.getElementById('file-input').click()"
          >
            <div id="file-label" class="file-info">ğŸ“‚ ç‚¹å‡»é€‰æ‹©å…¨æ™¯å›¾</div>
            <div class="file-hint">æ”¯æŒ JPG / PNG</div>
          </div>
          <input
            type="file"
            id="file-input"
            accept="image/*"
            style="display: none"
          />
        </div>

        <div class="control-group">
          <label>ç®—æ³•é€‰æ‹© (æ‰‹æœºæ¨è Linear)</label>
          <select id="algo-select">
            <option value="linear">Linear (é€Ÿåº¦å¿«)</option>
            <option value="cubic" selected>Cubic (å‡è¡¡)</option>
            <option value="lanczos">Lanczos (ç”»è´¨æœ€ä½³/æ…¢)</option>
          </select>
        </div>

        <div class="control-group">
          <div class="btn-group">
            <button
              id="process-btn"
              class="btn-primary"
              disabled
              onclick="startProcessing()"
            >
              å¼€å§‹åˆ‡ç‰‡
            </button>
            <button
              id="cancel-btn"
              class="btn-danger"
              onclick="cancelProcessing()"
            >
              å–æ¶ˆå¤„ç†
            </button>
          </div>
          <div id="progress-area">
            <div class="progress-track">
              <div id="progress-bar" class="progress-bar"></div>
            </div>
            <div id="status-text" class="status-text"></div>
          </div>
        </div>

        <div id="slices-grid"></div>
      </div>
    </div>

    <!-- Worker Logic -->
    <script id="worker-code" type="javascript/worker">
      function clamp(x, min, max) { return Math.min(max, Math.max(x, min)); }
      function mod(x, n) { return ((x % n) + n) % n; }

      function copyPixelNearest(r, w) {
          const {width, height, data} = r;
          return (x, y, to) => {
              const idx = 4 * (clamp(Math.round(y), 0, height-1) * width + clamp(Math.round(x), 0, width-1));
              w.data[to]=data[idx]; w.data[to+1]=data[idx+1]; w.data[to+2]=data[idx+2]; w.data[to+3]=255;
          };
      }
      function copyPixelBilinear(r, w) {
          const {width, height, data} = r;
          return (x, y, to) => {
              const xl=Math.floor(x), xr=Math.ceil(x), yl=Math.floor(y), yr=Math.ceil(y);
              const xf=x-xl, yf=y-yl;
              const p00=4*(clamp(yl,0,height-1)*width+clamp(xl,0,width-1));
              const p10=4*(clamp(yl,0,height-1)*width+clamp(xr,0,width-1));
              const p01=4*(clamp(yr,0,height-1)*width+clamp(xl,0,width-1));
              const p11=4*(clamp(yr,0,height-1)*width+clamp(xr,0,width-1));
              for(let i=0;i<3;i++){
                  const t=data[p00+i]*(1-xf)+data[p10+i]*xf, b=data[p01+i]*(1-xf)+data[p11+i]*xf;
                  w.data[to+i]=t*(1-yf)+b*yf;
              }
              w.data[to+3]=255;
          };
      }
      function copyPixelLanczos(r, w) {
          const {width, height, data} = r; const fs=3;
          const k = v => (v===0)?1:(fs*Math.sin(Math.PI*v)*Math.sin(Math.PI*v/fs)/(Math.PI*v)**2);
          return (x, y, to) => {
              const xl=Math.floor(x), yl=Math.floor(y);
              let rgb=[0,0,0];
              for(let i=-fs+1;i<=fs;i++){
                  for(let j=-fs+1;j<=fs;j++){
                      const w=k(y-(yl+i))*k(x-(xl+j));
                      const idx=4*(clamp(yl+i,0,height-1)*width+clamp(xl+j,0,width-1));
                      rgb[0]+=data[idx]*w; rgb[1]+=data[idx+1]*w; rgb[2]+=data[idx+2]*w;
                  }
              }
              w.data[to]=rgb[0]; w.data[to+1]=rgb[1]; w.data[to+2]=rgb[2]; w.data[to+3]=255;
          };
      }

      const orientations = {
          pz: (o,x,y)=>{o.x=-1;o.y=-x;o.z=-y}, nz: (o,x,y)=>{o.x=1;o.y=x;o.z=-y},
          px: (o,x,y)=>{o.x=x;o.y=-1;o.z=-y}, nx: (o,x,y)=>{o.x=-x;o.y=1;o.z=-y},
          py: (o,x,y)=>{o.x=-y;o.y=-x;o.z=1}, ny: (o,x,y)=>{o.x=y;o.y=-x;o.z=-1}
      };

      self.onmessage = ({data}) => {
          const { readData, face, interp } = data;
          const size = Math.max(256, Math.floor(readData.width / 4));
          const writeData = new ImageData(size, size);
          const copy = (interp==='lanczos')?copyPixelLanczos(readData,writeData):
                       (interp==='linear')?copyPixelBilinear(readData,writeData):
                       copyPixelNearest(readData,writeData);
          const orient = orientations[face];
          const c = {};
          for(let x=0;x<size;x++){
              for(let y=0;y<size;y++){
                  orient(c, 2*(x+0.5)/size-1, 2*(y+0.5)/size-1);
                  const r=Math.sqrt(c.x**2+c.y**2+c.z**2);
                  const lon=((Math.atan2(c.y,c.x)+Math.PI)%(2*Math.PI));
                  const lat=Math.acos(c.z/r);
                  copy(readData.width*lon/Math.PI/2-0.5, readData.height*lat/Math.PI-0.5, 4*(y*size+x));
              }
          }
          self.postMessage({ buffer: writeData.data.buffer, size }, [writeData.data.buffer]);
      };
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const uiContainer = document.getElementById("ui-container");
      const panelToggle = document.getElementById("panel-toggle");
      panelToggle.addEventListener("click", () => {
        uiContainer.classList.toggle("collapsed");
      });
      function expandUI() {
        uiContainer.classList.remove("collapsed");
      }

      let scene, camera, renderer, sphere, controls;
      let originalImageData = null;
      let currentWorker = null;
      let isCancelled = false;

      initThree();

      function initThree() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 0.1);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.rotateSpeed = -0.5;
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.addEventListener("start", () => (controls.autoRotate = false));

        const geo = new THREE.SphereGeometry(500, 60, 40);
        geo.scale(-1, 1, 1);
        sphere = new THREE.Mesh(
          geo,
          new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true })
        );
        scene.add(sphere);

        animate();
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      document.getElementById("file-input").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        document.getElementById("file-label").innerHTML = `<b>${file.name}</b>`;
        const url = URL.createObjectURL(file);

        new THREE.TextureLoader().load(url, (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.minFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          sphere.material.dispose();
          sphere.material = new THREE.MeshBasicMaterial({ map: tex });
        });

        const img = new Image();
        img.src = url;
        img.onload = () => {
          const cvs = document.createElement("canvas");
          cvs.width = img.width;
          cvs.height = img.height;
          cvs.getContext("2d").drawImage(img, 0, 0);
          originalImageData = cvs
            .getContext("2d")
            .getImageData(0, 0, img.width, img.height);
          document.getElementById("process-btn").disabled = false;
          expandUI();
        };
      });

      window.cancelProcessing = () => {
        isCancelled = true;
        if (currentWorker) currentWorker.terminate();
        resetUI("å·²å–æ¶ˆå¤„ç†");
      };

      window.startProcessing = async () => {
        if (!originalImageData) return;
        isCancelled = false;

        const btn = document.getElementById("process-btn");
        const cancelBtn = document.getElementById("cancel-btn");
        const grid = document.getElementById("slices-grid");
        const pBar = document.getElementById("progress-bar");
        const pArea = document.getElementById("progress-area");
        const status = document.getElementById("status-text");

        grid.innerHTML = "";
        btn.style.display = "none";
        cancelBtn.style.display = "block";
        pArea.style.display = "block";
        pBar.style.width = "0%";

        const faces = [
          { id: "px", n: "Right", f: "pano_r" },
          { id: "nx", n: "Left", f: "pano_l" },
          { id: "py", n: "Up", f: "pano_u" },
          { id: "ny", n: "Down", f: "pano_d" },
          { id: "pz", n: "Front", f: "pano_f" },
          { id: "nz", n: "Back", f: "pano_b" },
        ];

        const workerBlob = new Blob(
          [document.getElementById("worker-code").textContent],
          { type: "text/javascript" }
        );
        const workerUrl = URL.createObjectURL(workerBlob);

        try {
          for (let i = 0; i < faces.length; i++) {
            if (isCancelled) break;
            const face = faces[i];
            status.innerText = `å¤„ç†ä¸­: ${face.n} (${i + 1}/6)`;
            pBar.style.width = (i / 6) * 100 + "%";

            await new Promise((resolve) => {
              currentWorker = new Worker(workerUrl);
              currentWorker.onmessage = (e) => {
                addSlice(
                  new ImageData(
                    new Uint8ClampedArray(e.data.buffer),
                    e.data.size,
                    e.data.size
                  ),
                  face.f
                );
                currentWorker.terminate();
                resolve();
              };
              currentWorker.postMessage({
                readData: originalImageData,
                face: face.id,
                interp: document.getElementById("algo-select").value,
              });
            });
            await new Promise((r) => setTimeout(r, 20));
          }
          if (!isCancelled) {
            pBar.style.width = "100%";
            resetUI("âœ… å®Œæˆï¼ç‚¹å‡»å›¾ç‰‡ä¸‹è½½");
          }
        } catch (e) {
          resetUI("é”™è¯¯: " + e.message);
        }
      };

      function resetUI(msg) {
        document.getElementById("status-text").innerText = msg;
        document.getElementById("process-btn").style.display = "block";
        document.getElementById("cancel-btn").style.display = "none";
      }

      function addSlice(imgData, name) {
        const cvs = document.createElement("canvas");
        cvs.width = imgData.width;
        cvs.height = imgData.height;
        cvs.getContext("2d").putImageData(imgData, 0, 0);
        cvs.toBlob((b) => {
          const u = URL.createObjectURL(b);
          const d = document.createElement("div");
          d.className = "slice-item";
          d.innerHTML = `<img src="${u}"><div class="slice-tag">${name}</div>`;
          d.onclick = () => {
            const a = document.createElement("a");
            a.href = u;
            a.download = name + ".png";
            a.click();
          };
          document.getElementById("slices-grid").appendChild(d);
        });
      }
    </script>
  </body>
</html>
